% grammar t2t

  main = applySyntactic<GrammarDef> applySyntactic<ParameterDef>* rewriteDef

  GrammarDef = "% grammar" name Rule+
  ParameterDef = "% parameter" name
  rewriteDef = "% rewrite" spaces rewriteRule+


  // just pass the grammar through to OhmJS - it parses and checks the grammar
  Rule = ~"% parameter" ~"% rewrite" any

  name  (a name)
    = nameFirst nameRest*

  nameFirst
    = "_"
    | letter

  nameRest
    = "_"
    | alnum


  // rewrite parsing section
  rewriteRule = rwRuleName spaces "[" spaces (rwParameterDef spaces)+ "]" spaces "=" spaces rewriteScope spaces

  rwRuleName = name
  rwPredicateDef = name
  rwIterPredicateDef = name ("+" | "*" | "?")
  rwParenthesizedIterPredicateDef = "(" rwParenPredicateDef+ ")" ("+" | "*" | "?")
  rwParameterDef = (rwParenthesizedIterPredicateDef | rwIterPredicateDef | rwPredicateDef)
  rwParenPredicateDef = name spaces

  rwPredicateRef = name

  rewriteScope =
    | "⎡" spaces name spaces "=" spaces #rewriteFormatString spaces rewriteScope spaces "⎦" spaces -- with_parameter
    | #rewriteFormatString -- raw
  rewriteFormatString = "‛" formatChar* "’"
  formatChar =
    | "⟪" rwPredicateRef "⟫" -- parameter_interpolation
    | "«" rwPredicateRef "»" -- predicate_interpolation
    | ~"‛" ~"’" ~"⎡" ~"⎦" ~"⟪" ~"⟫" ~"«" ~"»" any -- raw_character


% rewrite

  main [GrammarDef ParameterDefs* rewriteDef] ‛«_.initialize_stacks ()»’ = ‛
'use strict'

var ohm = require('ohm-js');


function set_top (stack, val) {
    stack.pop ();
    stack.push (val);
}

function top (stack) {
    let r = stack.pop ();
    stack.push (r);
    return r;
}

let return_value_stack = [];
let rule_name_stack = [];
«ParameterDefs»
«GrammarDef»
«rewriteDef»

function main (src) {
    let parser = ohm.grammar (grammar);
    let cst = parser.match (src);
    if (cst.succeeded ()) {
	let cstSemantics = parser.createSemantics ();
	cstSemantics.addOperation ('rwr', rewrite_code);
	var generated_code = cstSemantics (cst).rwr ();
	return generated_code;
    } else {
	console.log (parser.trace (src).toString ());
	throw ("grammar error");
    }
}

let fs = require('fs');
let src = fs.readFileSync(0, 'utf-8');
var result = main (src);
console.log (result);
’

  ParameterDef [_p name] = ‛\nlet «name»_stack = [];«_.memo_parameter (name)»’

  GrammarDef [_ name Rules+] = ‛
const grammar = String.raw\\\`
«name» {
«Rules»
}
\\\`;
’

  rewriteDef [_ ws rewriteRules+] = ‛const rewrite_code = {«rewriteRules»
    _terminal: function () { return this.sourceString; },
    _iter: function (...children) { return children.map(c => c.rwr ()); }
};
’

  Rule [cs] = ‛«cs»’

  name [nameFirst nameRest*] = ‛«nameFirst»«nameRest»’

  nameFirst [c] = ‛«c»’
  nameRest [c] = ‛«c»’


  rewriteRule [rwName ws1 lb ws2 rwParameterDefs+ ws3+ rb ws4 _eq ws5 rewriteScope ws6] = ‛
«rwName» : function («rwParameterDefs») {
return_value_stack.push ("");
rule_name_stack.push ("");
set_top (rule_name_stack, "«rwName»");
«_.foreach_parameter ("_stack.push ('');")»
«_.predicate_expansions_as_string ()»
«rewriteScope»
«_.foreach_parameter ("_stack.pop ();")»
rule_name_stack.pop ();
return return_value_stack.pop ();
},’
  
  rwRuleName [name] =‛«name»’
  rwPredicateDef [name] =‛«name», «_.memo_predicate (name)»’
  rwIterPredicateDef [name op] = ‛«name», «_.memo_iter_predicate (name)»’
  rwParenthesizedIterPredicateDef [lb defs+ rb op] = ‛«defs»’
  rwParameterDef [def] = ‛«def»’
  rwPredicateRef [name] =‛«name»’
  rwParenPredicateDef [name ws] = ‛«name», «_.memo_iter_predicate (name)»’

  rewriteScope_with_parameter [lb ws1 name ws2 _eq ws3 rewriteFormatString ws4 rewriteScope ws5 rb ws6] = ‛set_top («name»_stack, \\\`«rewriteFormatString»\\\`);\n«rewriteScope»’
  rewriteScope_raw [rewriteFormatString] = ‛set_top (return_value_stack, \\\`«rewriteFormatString»\\\`);\n’
  
  rewriteFormatString [lq formatChars* rq] = ‛«formatChars»’
  formatChar_predicate_interpolation [lb rwRef rb] = ‛\\\$\\\{«rwRef»\\\}’
  formatChar_parameter_interpolation [lb rwRef rb] = ‛\\\$\\\{top («rwRef»_stack)\\\}’
  formatChar_raw_character [c] = ‛«c»’
  